<!DOCTYPE html>
<html lang="zh">
        <head>
                        <meta charset="utf-8" />
                        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                        <meta name="generator" content="Pelican" />
                        <title>My Tech Blog - Redis</title>
                        <link rel="stylesheet" href="/theme/css/main.css" />
        </head>

        <body id="index" class="home">
                <header id="banner" class="body">
                        <h1><a href="/">My Tech Blog</a></h1>
                        <nav><ul>
                                                <li><a href="/category/ru-men.html">入门</a></li>
                        </ul></nav>
                </header><!-- /#banner -->

                <aside id="featured" class="body">
                    <article>
                        <h1 class="entry-title"><a href="/redis-fen-bu-shi-suo-jie-jue-celery-ren-wu-bing-fa-chong-tu.html">Redis 分布式锁：解决 Celery 任务并发冲突</a></h1>
<footer class="post-info">
        <abbr class="published" title="2025-11-28T16:00:00+08:00">
                Published: Fri 28 November 2025
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="/author/samuelchen.html">samuel.chen</a>
                </address>
        <p>In <a href="/category/ru-men.html">入门</a>.</p>
<p>tags: <a href="/tag/redis.html">Redis</a> <a href="/tag/python.html">Python</a> </p>        
</footer><!-- /.post-info --><h4>一、应用背景：为什么 Celery 需要 Redis 分布式锁？</h4>
<p>Celery 是一个强大的分布式任务队列，它允许您将耗时的操作（如发送邮件、处理文件、生成报告）放到后台由独立的 Worker 进程来执行。</p>
<p>为了提高处理能力，生产环境通常会运行多个 Worker 进程，甚至将它们部署在多台不同的服务器上。</p>
<p>当两个或更多的 Worker <strong>在同一时刻</strong>，从任务队列中获取到<strong>针对同一个资源</strong>的任务时，就会发生并发冲突。</p>
<p>这种架构下，容易出现以下问题：</p>
<ul>
<li><strong>定时任务重复执行</strong>：例如每分钟执行的定时任务，若前一次任务执行超时（如处理耗时超过 1 分钟），下一个周期的 Worker 会重复启动任务；</li>
<li><strong>并发任务资源竞争</strong>：多个 Worker 同时执行修改同一数据库记录、调用同一第三方接口的任务，导致数据错乱或重复操作；</li>
<li><strong>跨节点任务互斥</strong>：本地锁（如 threading.Lock）仅能限制单个 Worker 内的并发，无法跨机器生效。</li>
</ul>
<p>而 Redis 分布式锁具备 <strong>「跨节点、原子性、高可用」</strong> 特性，恰好匹配 Celery 分布式部署的需求，能实现全局任务互斥。</p>
<h4>二、Redis 分布式锁核心原理</h4>
<p>Redis 分布式锁的核心是利用 Redis 的原子操作来保证「锁的唯一性」。</p>
<p>其关键设计包含两个部分：<strong>加锁和释放锁</strong>。</p>
<h5>2.1 加锁：原子命令 <code>SET ... NX ... EX</code></h5>
<p>加锁操作必须是原子的，即“检查锁是否存在”和“创建锁”这两个步骤必须合并为一步完成。Redis 的 <code>SET</code> 命令提供了完美的解决方案：</p>
<div class="highlight"><pre><span></span><code>SET<span class="w"> </span>lock_key<span class="w"> </span>unique_value<span class="w"> </span>NX<span class="w"> </span>EX<span class="w"> </span>timeout
</code></pre></div>

<ul>
<li><code>lock_key</code>：锁的唯一名称，例如 <code>lock:generate_report:task001</code>。</li>
<li><code>unique_value</code>：一个随机生成的唯一值（如 UUID），用于标识锁的持有者。这能防止一个客户端错误地释放了另一个客户端持有的锁。</li>
<li><code>NX</code> (Not exists)：这是实现互斥的关键。它告诉 Redis，只有当 <code>lock_key</code> <strong>不存在</strong>时，才执行 <code>SET</code> 操作。如果键已存在，命令将失败。</li>
<li><code>EX timeout</code> (Expire)：为锁设置一个自动过期时间（单位：秒）。这是一个安全阀，可以防止因 Worker 崩溃而未能手动释放锁，导致锁永久存在（即“死锁”）。</li>
</ul>
<h5>2.2 释放锁：使用 Lua 脚本保证原子性</h5>
<p>释放锁时，同样需要保证原子性。我们必须先<strong>验证</strong>锁是否仍然归自己所有，然后再<strong>删除</strong>它。如果分两步执行，可能会在验证通过后、删除前，锁因超时而过期，并被另一个 Worker 获取，此时若再执行删除，就会误删他人的锁。</p>
<p>最安全的做法是使用 Lua 脚本，因为 Redis 会保证整个脚本在执行期间不会被其他命令打断。</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 脚本逻辑：先 GET 锁的值，与客户端传入的 unique_value 比较</span>
<span class="c1">-- 如果值匹配，说明锁确实是自己加的，则执行 DEL 删除锁</span>
<span class="kr">if</span> <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;GET&quot;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="kr">then</span>
  <span class="kr">return</span> <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;DEL&quot;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="kr">else</span>
  <span class="kr">return</span> <span class="mi">0</span>
<span class="kr">end</span>
</code></pre></div>

<ul>
<li><code>KEYS[1]</code>：代表 <code>lock_key</code>。</li>
<li><code>ARGV[1]</code>：代表 <code>unique_value</code>。</li>
</ul>
<p>通过这种“检查并删除”的原子操作，我们就能安全地释放锁，而不会影响到其他 Worker。</p>
<p>幸运的是，<code>redis-py</code> 这类成熟的客户端库已经将这些复杂的底层逻辑封装好了，我们只需调用简单的方法即可，如下文代码所示。</p>
<h4>三、代码实现：防止重复执行耗时查询</h4>
<p>让我们构思一个常见的场景：在一个数据分析平台，用户可以点击按钮，触发一个后台任务来执行一项耗时的数据查询和报表生成。</p>
<ul>
<li><strong>功能</strong>：一个名为 <code>run_complex_query_task</code> 的 Celery 任务，它接收一个 <code>query_id</code> 作为参数，代表一个特定的查询请求。</li>
<li>
<p><strong>流程</strong>：</p>
</li>
<li>
<p>根据 <code>query_id</code> 获取查询参数。</p>
</li>
<li>连接数据库，执行一个可能耗时数分钟的复杂 SQL 查询。</li>
<li>处理查询结果，生成报表，并缓存结果。</li>
<li>
<p><strong>问题</strong>：</p>
</li>
<li>
<p>如果用户因为网络延迟或不耐烦，<strong>连续多次点击</strong>了“生成报表”按钮，会导致同一个 <code>run_complex_query_task</code> 任务被多次放入队列。</p>
</li>
<li><strong>Worker A</strong> 获取到第一个任务，开始执行耗时的数据库查询。</li>
<li>几乎在同一时刻，<strong>Worker B</strong> 获取到第二个任务，也开始执行完全相同的查询。</li>
<li>
<p><strong>后果</strong>：</p>
</li>
<li>
<p><strong>数据库过载</strong>：多个重量级查询同时在数据库上运行，消耗大量 CPU 和 I/O，可能拖慢整个应用。</p>
</li>
<li><strong>资源浪费</strong>：服务器重复执行了相同的计算和数据处理，浪费了宝贵的计算资源。</li>
<li><strong>结果覆盖</strong>：如果任务需要将结果写入缓存或文件，后完成的任务会覆盖先完成的，造成不必要的写操作。</li>
</ul>
<p><strong>分布式锁</strong>可以确保在任何时刻，只有一个 Worker 能为指定的 <code>query_id</code> 执行查询任务。</p>
<p>下面我们通过一个完整的 Python 脚本来演示如何解决这个问题。</p>
<h5>3.1 环境安装</h5>
<div class="highlight"><pre><span></span><code>pip<span class="w"> </span>install<span class="w"> </span>celery<span class="w"> </span>redis
</code></pre></div>

<h5>3.2 示例代码 (<code>tasks.py</code>)</h5>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">from</span> <span class="nn">celery</span> <span class="kn">import</span> <span class="n">Celery</span>
<span class="kn">from</span> <span class="nn">redis</span> <span class="kn">import</span> <span class="n">Redis</span>
<span class="kn">from</span> <span class="nn">redis.lock</span> <span class="kn">import</span> <span class="n">Lock</span>
<span class="kn">from</span> <span class="nn">redis.exceptions</span> <span class="kn">import</span> <span class="n">LockError</span>

<span class="c1"># 1. Celery 和 Redis 客户端初始化</span>
<span class="c1"># 假设 Redis 运行在本地</span>
<span class="n">BROKER_URL</span> <span class="o">=</span> <span class="s1">&#39;redis://:000000@127.0.0.1:6379/0&#39;</span>
<span class="n">celery_app</span> <span class="o">=</span> <span class="n">Celery</span><span class="p">(</span><span class="s1">&#39;task&#39;</span><span class="p">,</span> <span class="n">broker</span><span class="o">=</span><span class="n">BROKER_URL</span><span class="p">)</span>
<span class="n">redis_client</span> <span class="o">=</span> <span class="n">Redis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="s1">&#39;000000&#39;</span><span class="p">,</span> <span class="n">decode_responses</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="nd">@celery_app</span><span class="o">.</span><span class="n">task</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;run_query&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">run_complex_query_task</span><span class="p">(</span><span class="n">query_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    一个模拟执行耗时查询的 Celery 任务，使用 Redis 分布式锁。</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 2. 定义锁的名称，确保对于同一个查询请求，锁的名称是唯一的</span>
    <span class="n">lock_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;lock:run_query:</span><span class="si">{</span><span class="n">query_id</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># 锁的超时时间（秒），应大于任务执行所需的最长时间，防止死锁</span>
    <span class="n">lock_timeout</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">10</span>  <span class="c1"># 10 分钟</span>
    <span class="c1"># 尝试获取锁的阻塞等待时间（秒），设为0表示不等待，立即返回</span>
    <span class="n">blocking_timeout</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">worker_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>  <span class="c1"># 用进程ID模拟 Worker 名称</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># 3. 使用 with 上下文管理器尝试获取锁</span>
        <span class="c1"># blocking_timeout=0: 如果锁被占用，会立即抛出 LockError</span>
        <span class="k">with</span> <span class="n">Lock</span><span class="p">(</span><span class="n">redis_client</span><span class="p">,</span> <span class="n">lock_key</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">lock_timeout</span><span class="p">,</span> <span class="n">blocking_timeout</span><span class="o">=</span><span class="n">blocking_timeout</span><span class="p">):</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Worker </span><span class="si">{</span><span class="n">worker_name</span><span class="si">}</span><span class="s2">] 成功获取锁 for query </span><span class="si">{</span><span class="n">query_id</span><span class="si">}</span><span class="s2">。&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Worker </span><span class="si">{</span><span class="n">worker_name</span><span class="si">}</span><span class="s2">] 开始执行复杂查询...&quot;</span><span class="p">)</span>

            <span class="c1"># --- 模拟核心业务逻辑 ---</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Worker </span><span class="si">{</span><span class="n">worker_name</span><span class="si">}</span><span class="s2">] -&gt; 正在连接数据库...&quot;</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Worker </span><span class="si">{</span><span class="n">worker_name</span><span class="si">}</span><span class="s2">] -&gt; 正在执行耗时的 SQL 查询 (query_id: </span><span class="si">{</span><span class="n">query_id</span><span class="si">}</span><span class="s2">)...&quot;</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Worker </span><span class="si">{</span><span class="n">worker_name</span><span class="si">}</span><span class="s2">] -&gt; 正在处理查询结果并生成报表...&quot;</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="c1"># --- 核心业务逻辑结束 ---</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Worker </span><span class="si">{</span><span class="n">worker_name</span><span class="si">}</span><span class="s2">] 查询 </span><span class="si">{</span><span class="n">query_id</span><span class="si">}</span><span class="s2"> 完成！报表已生成。锁将自动释放。&quot;</span><span class="p">)</span>
            <span class="c1"># with 语句结束时，锁会自动被安全地释放</span>

    <span class="k">except</span> <span class="n">LockError</span><span class="p">:</span>
        <span class="c1"># 4. 如果未能获取锁，说明有另一个 Worker 正在处理</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Worker </span><span class="si">{</span><span class="n">worker_name</span><span class="si">}</span><span class="s2">] 获取锁失败。查询 </span><span class="si">{</span><span class="n">query_id</span><span class="si">}</span><span class="s2"> 正在由其他 Worker 执行，本次任务跳过。&quot;</span><span class="p">)</span>
        <span class="k">return</span>  <span class="c1"># 直接返回，放弃执行</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Worker </span><span class="si">{</span><span class="n">worker_name</span><span class="si">}</span><span class="s2">] 处理查询 </span><span class="si">{</span><span class="n">query_id</span><span class="si">}</span><span class="s2"> 时发生未知错误: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># 即使发生异常，with 语句也能确保锁被释放（如果已获取）</span>
        <span class="k">raise</span>  <span class="c1"># 重新抛出异常，以便 Celery 可以根据配置进行重试</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># 这是一个用于触发任务的脚本</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;正在向队列发送两个针对同一查询ID的重复任务...&quot;</span><span class="p">)</span>
    <span class="n">query_to_run</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;rates_checking_report_</span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">run_complex_query_task</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">query_to_run</span><span class="p">])</span>
    <span class="n">run_complex_query_task</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">query_to_run</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;任务已发送。请观察 Worker 日志。&quot;</span><span class="p">)</span>
</code></pre></div>

<h4>四、运行与演示</h4>
<p><strong>启动第一个 Worker</strong>：
   打开一个终端，运行以下命令：</p>
<div class="highlight"><pre><span></span><code>celery<span class="w"> </span>-A<span class="w"> </span>tasks<span class="w"> </span>worker<span class="w"> </span>--loglevel<span class="o">=</span>info<span class="w"> </span>-c<span class="w"> </span><span class="m">1</span><span class="w"> </span>-n<span class="w"> </span>worker1@%h<span class="w"> </span>-P<span class="w"> </span>eventlet
</code></pre></div>

<p><strong>启动第二个 Worker</strong>：
   <strong>再打开一个新的终端</strong>，运行以下命令，启动第二个 Worker：</p>
<div class="highlight"><pre><span></span><code>celery<span class="w"> </span>-A<span class="w"> </span>tasks<span class="w"> </span>worker<span class="w"> </span>--loglevel<span class="o">=</span>info<span class="w"> </span>-c<span class="w"> </span><span class="m">1</span><span class="w"> </span>-n<span class="w"> </span>worker2@%h<span class="w"> </span>-P<span class="w"> </span>eventlet
</code></pre></div>

<p>现在您有两个独立的 Worker 进程在同时等待任务。</p>
<p><strong>触发任务</strong>：
   <strong>再打开第三个终端</strong>，运行我们的 Python 脚本来发送任务：</p>
<div class="highlight"><pre><span></span><code>python<span class="w"> </span>tasks.py
</code></pre></div>

<p>这个脚本会立即向队列中发送两个完全相同的任务。</p>
<div class="highlight"><pre><span></span><code>正在向队列发送两个针对同一查询ID的重复任务...
任务已发送。请观察<span class="w"> </span>Worker<span class="w"> </span>日志。
</code></pre></div>

<p><strong>观察结果</strong>：
   您会看到，几乎在同一时间，两个 Worker 都收到了任务。但是，只有一个 Worker 能够成功获取锁并执行业务逻辑，而另一个会因为获取锁失败而直接跳过。</p>
<p><strong>Worker 1 的日志如下</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="p">[...</span><span class="w"> </span><span class="n">INFO</span><span class="o">/</span><span class="n">MainProcess</span><span class="p">]</span><span class="w"> </span><span class="n">Received</span><span class="w"> </span><span class="n">task</span><span class="o">:</span><span class="w"> </span><span class="n">run_query</span><span class="p">[</span><span class="mi">2</span><span class="n">cdf6f09</span><span class="o">-</span><span class="mf">51e2</span><span class="o">-</span><span class="mi">4</span><span class="n">c2a</span><span class="o">-</span><span class="n">b181</span><span class="o">-</span><span class="mi">70</span><span class="n">df4fa28dd5</span><span class="p">]</span><span class="w">  </span>
<span class="p">[</span><span class="n">Worker</span><span class="w"> </span><span class="mi">27996</span><span class="p">]</span><span class="w"> </span><span class="err">成功获取锁</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="n">rates_checking_report_20251127</span><span class="err">。</span>
<span class="p">[</span><span class="n">Worker</span><span class="w"> </span><span class="mi">27996</span><span class="p">]</span><span class="w"> </span><span class="err">开始执行复杂查询</span><span class="p">...</span>
<span class="p">[</span><span class="n">Worker</span><span class="w"> </span><span class="mi">27996</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">正在连接数据库</span><span class="p">...</span>
<span class="p">[</span><span class="n">Worker</span><span class="w"> </span><span class="mi">27996</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">正在执行耗时的</span><span class="w"> </span><span class="kr">SQL</span><span class="w"> </span><span class="err">查询</span><span class="w"> </span><span class="p">(</span><span class="n">query_id</span><span class="o">:</span><span class="w"> </span><span class="n">report_daily_sales_20251127</span><span class="p">)...</span>
<span class="p">[</span><span class="n">Worker</span><span class="w"> </span><span class="mi">27996</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">正在处理查询结果并生成报表</span><span class="p">...</span>
<span class="p">[</span><span class="n">Worker</span><span class="w"> </span><span class="mi">27996</span><span class="p">]</span><span class="w"> </span><span class="err">查询</span><span class="w"> </span><span class="n">report_daily_sales_20251127</span><span class="w"> </span><span class="err">完成！报表已生成。锁将自动释放。</span>
<span class="p">[...</span><span class="w"> </span><span class="n">INFO</span><span class="o">/</span><span class="n">MainProcess</span><span class="p">]</span><span class="w"> </span><span class="n">Task</span><span class="w"> </span><span class="n">run_query</span><span class="p">[</span><span class="mi">2</span><span class="n">cdf6f09</span><span class="o">-</span><span class="mf">51e2</span><span class="o">-</span><span class="mi">4</span><span class="n">c2a</span><span class="o">-</span><span class="n">b181</span><span class="o">-</span><span class="mi">70</span><span class="n">df4fa28dd5</span><span class="p">]</span><span class="w"> </span><span class="n">succeeded</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="mf">10.03099999999904</span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="n">None</span>
</code></pre></div>

<p><strong>Worker 2 的日志如下</strong>：</p>
<div class="highlight"><pre><span></span><code>[... INFO/MainProcess] Received task: run_query[f61bd4cd-908c-474e-a8cc-1896aed7ec43] 
[Worker 54321] 获取锁失败。查询 report_daily_sales_20231027 正在由其他 Worker 执行，本次任务跳过。
[... INFO/MainProcess] Task run_query[f61bd4cd-908c-474e-a8cc-1896aed7ec43] succeeded in 0.0s: None
</code></pre></div>                    </article>
                </aside><!-- /#featured -->
                    <section id="content" class="body">
                        <h1>Other articles</h1>
                        <hr />
                        <ol id="posts-list" class="hfeed">

                <li><article class="hentry">
                    <header>
                        <h1><a href="/redisfen-bu-shi-xiao-xi-dui-lie.html" rel="bookmark"
                               title="Permalink to Redis分布式消息队列">Redis分布式消息队列</a></h1>
                    </header>

                    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2025-11-28T16:00:00+08:00">
                Published: Fri 28 November 2025
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="/author/samuelchen.html">samuel.chen</a>
                </address>
        <p>In <a href="/category/ru-men.html">入门</a>.</p>
<p>tags: <a href="/tag/redis.html">Redis</a> <a href="/tag/python.html">Python</a> </p>        
</footer><!-- /.post-info -->                        <h4>一、消息队列基础概述</h4>
<h5>1.1 定义</h5>
<p><strong>消息队列（Message Queue）</strong> 是一种应用程序间的异步通信机制，</p>
<p>核心采用 生产者-消费者模型(Producer-Consumer Model)</p>
<p>生产 …</p>
                        <a class="readmore" href="/redisfen-bu-shi-xiao-xi-dui-lie.html">read more</a>
                    </div><!-- /.entry-content -->
                </article></li>

                <li><article class="hentry">
                    <header>
                        <h1><a href="/redishuan-cun-re-dian-shu-ju.html" rel="bookmark"
                               title="Permalink to Redis缓存热点数据">Redis缓存热点数据</a></h1>
                    </header>

                    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2025-11-28T16:00:00+08:00">
                Published: Fri 28 November 2025
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="/author/samuelchen.html">samuel.chen</a>
                </address>
        <p>In <a href="/category/ru-men.html">入门</a>.</p>
<p>tags: <a href="/tag/redis.html">Redis</a> <a href="/tag/python.html">Python</a> </p>        
</footer><!-- /.post-info -->                        <h4>一、场景说明</h4>
<p>高频访问数据直接查数据库会导致响应慢，用Redis缓存可将响应时间从毫秒级降至微秒级，减轻数据库压力。</p>
<h4>二、实现思路</h4>
<p><strong>Cache-Aside 策略</strong></p>
<p>Cache-Aside意为旁路缓存模式，是应用最为广泛的一 …</p>
                        <a class="readmore" href="/redishuan-cun-re-dian-shu-ju.html">read more</a>
                    </div><!-- /.entry-content -->
                </article></li>

                <li><article class="hentry">
                    <header>
                        <h1><a href="/redisjie-shao.html" rel="bookmark"
                               title="Permalink to Redis介绍">Redis介绍</a></h1>
                    </header>

                    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2025-11-28T16:00:00+08:00">
                Published: Fri 28 November 2025
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="/author/samuelchen.html">samuel.chen</a>
                </address>
        <p>In <a href="/category/ru-men.html">入门</a>.</p>
<p>tags: <a href="/tag/redis.html">Redis</a> <a href="/tag/python.html">Python</a> </p>        
</footer><!-- /.post-info -->                        <h3>一、Redis是什么？</h3>
<p><strong>Redis （Remote Dictionary Server）</strong> 是指远程字典服务器，它是一个基于内存的（K/V）存储系统。</p>
<ul>
<li><strong>字典服务器</strong>：这里的“字典”指的是数据的组织方式 …</li></ul>
                        <a class="readmore" href="/redisjie-shao.html">read more</a>
                    </div><!-- /.entry-content -->
                </article></li>
                    </ol><!-- /#posts-list -->
                    </section><!-- /#content -->
                <section id="extras" class="body">
                                <div class="blogroll">
                                        <h2>links</h2>
                                        <ul>
                                                        <li><a href="https://getpelican.com/">Pelican</a></li>
                                                        <li><a href="https://www.python.org/">Python.org</a></li>
                                                        <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                                                        <li><a href="#">You can modify those links in your config file</a></li>
                                        </ul>
                                </div><!-- /.blogroll -->
                                <div class="social">
                                        <h2>social</h2>
                                        <ul>

                                                        <li><a href="#">You can add links in your config file</a></li>
                                                        <li><a href="#">Another social link</a></li>
                                        </ul>
                                </div><!-- /.social -->
                </section><!-- /#extras -->

                <footer id="contentinfo" class="body">
                        <address id="about" class="vcard body">
                                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                        </address><!-- /#about -->

                        <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
                </footer><!-- /#contentinfo -->

        </body>
</html>